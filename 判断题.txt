第一章

1. 软件生命周期是指软件的产生直到报废的生命周期。（✓）
解释：正确。软件生命周期完整地包含了从软件构思开始到最终淘汰的整个过程。

2. 软件工程包括两大部分:技术和管理。（✓）
解释：正确。软件工程包含技术层面和管理层面两个主要方面。

3. 软件工程就是编程序。（✗）
解释：错误。软件工程远不止编程,还包括需求分析、设计、测试、维护等多个环节。

4. 软件工程的实质就是按工程化的原则和方法进行软件开发。（✓）
解释：正确。这体现了软件工程的核心思想。

第二章

1. 软件生命周期是软件开发过程的主要依据。（✓）
解释：正确。软件生命周期模型为软件开发提供了基本框架。

2. 软件开发过程中最重要的阶段是编码阶段。（✗）
解释：错误。需求分析和设计阶段同样重要,甚至更为关键。

3. 软件测试的目的是证明软件中没有错误。（✗）
解释：错误。测试的目的是发现错误,而不是证明没有错误。

4. 软件维护是软件生命周期中最长的阶段。（✓）
解释：正确。维护阶段通常占据软件生命周期的大部分时间。

5. 可行性研究是软件开发的第一个阶段。（✓）
解释：正确。可行性研究是项目启动前的重要评估阶段。

第三章

1. 用于需求分析的软件工具应该能够保证需求的正确性、完整性、现实性和有效性。（✓）
解释：正确。这些都是需求分析工具必须具备的基本功能。

2. 需求分析是开发的工作,用户的参与度不大。（✗）
解释：错误。需求分析需要用户的深度参与,因为只有用户才最清楚自己的真实需求。

3. 需求规格说明书在软件开发中具有重要作用,它也可以作为软件可行性研究的依据。（✗）
解释：错误。需求规格说明书是在可行性研究之后才产生的文档。

4. 需求分析的主要目的是解决软件做什么的问题。（✓）
解释：正确。需求分析主要关注系统应该做什么，而如何实现则是设计阶段要解决的问题。

5. 需求规格说明书描述了系统每个功能的细节。（✗）
解释：错误。需求规格说明书主要描述系统功能的需求,而不是具体实现细节。

6. 非功能需求是从各个角度对系统的约束,反映了应用对软件系统质量和特性的额外要求。（✓）
解释：正确。这是对非功能需求的准确描述,包括性能、可靠性、安全性等方面的要求。

7. 需求分析阶段的成果主要是需求规格说明书,但该成果与软件设计、编码、测试直至维护关系不大。（✗）
解释：错误。需求规格说明书是整个软件开发过程的基础,与后续所有阶段都密切相关。

第四章

1. 分层的DFD图可以用于可行性研究阶段，描述系统的功能需求。（✗）
解释：错误。DFD图主要用于需求分析阶段描述系统的功能需求,而不是可行性研究阶段。

2. 信息建模方法是从数据的角度来建立信息模型的，最常用的描述信息模型的方法是E-R图。（✓）
解释：正确。E-R图是最常用的信息建模工具,它能够清晰地表达实体之间的关系。

3. 在需求分析阶段主要采用图形工具来描述的原因是图形的信息量大，便于描述规模大的软件系统。（✗）
解释：错误。采用图形工具的主要原因是图形直观、易于理解和交流,而不仅仅是因为信息量大。

4. 在一张状态图中只能有一个初态，而终态可以没有，也可以有多个。（✓）
解释：正确。状态图规定只能有一个初始状态,但终止状态可以没有或有多个,这符合实际系统的特点。

第五章

1. UML是一种建模语言，是一种标准的表示，是一种方法。（✗）
解释：错误。UML是统一建模语言(Unified Modeling Language),是一种标准的建模语言,但它不是一种方法。

2. 类图用来表示系统中的类和类之间的关系，它是对系统静态结构的描述。（✓）
解释：正确。类图确实是描述系统静态结构的重要工具,展示了类之间的关系。

3. 在面向对象的软件开发方法中，每个类都存在其相应的对象，类是对象的实例，对象是生成类的模板。（✗）
解释：错误。这里关系反了,类是对象的模板,对象是类的实例,而不是相反。

4. 顺序图用于描述对象是如何交互的，并且重点放在消息序列上。（✓）
解释：正确。顺序图主要用于描述对象之间的交互顺序和消息传递。

5. 继承性是父类和子类之间共享数据结构和消息的机制，这是类之间的一种关系。（✗）
解释：错误。继承性是子类继承父类的属性和方法的机制,不仅仅是共享,而是一种"是一种"的关系。

6. 多态性增强了软件的灵活性和重用性，允许用更为明确、易懂的方式去建立通用的软件，并且继承性相结合使软件具有更广泛的重用性和可扩充性。（✓）
解释：正确。多态性确实提高了软件的灵活性和可重用性,是面向对象的重要特征。

7. 类的封装比对象封装更具体、更细致。（✗）
解释：错误。类的封装是在抽象层面上的,而对象封装是具体实现层面的。

8. 用例之间有扩展、使用和组合等几种关系。（✓）
解释：正确。用例之间确实存在这些关系类型,用于描述用例间的不同交互方式。

9. 活动图用于描述活动作为其结果，着重描述操作实现过程完成的工作，以及用例实例或类中的活动。（✓）
解释：正确。活动图主要用于描述业务流程和操作的实现过程。

10. UML语言支持面向对象的主要概念，并与具体的开发过程相关。（✗）
解释：错误。UML是独立于开发过程的建模语言,可以用于任何开发过程。

11. 部署图用于描述系统硬件的物理拓扑结构，以及在此结构上执行的软件。（✓）
解释：正确。部署图确实用于描述系统的物理架构和软件部署情况。

第六章

1. 模型是对现实的简化，建模是为了更好地理解所开发的系统。（✓）
解释：正确。模型的目的就是通过适当的简化来帮助我们更好地理解复杂系统。

2. 在面向对象的需求分析方法中，建立动态模型是最主要的任务。（✗）
解释：错误。面向对象分析中,静态模型(类图)、动态模型和功能模型都同样重要,不能动态模型最主要。

3. 面向对象分析阶段建立的3个模型中，核心模型是功能模型。（✗）
解释：错误。在面向对象分析中,对象模型(类图)才是核心模型,它描述了系统的基本结构。

4. 对象模型的描述工具是状态图。（✗）
解释：错误。对象模型的主要描述工具是类图,而状态图是用来描述动态模型的工具。

第七章

1. 模块独立要求高耦合、低聚合。（✗）
解释：错误。模块独立性原则要求的是低耦合、高聚合,这样才能提高模块的独立性和可维护性。

2. 软件设计说明书是软件概要设计的主要成果。（✗）
解释：错误。软件设计说明书是详细设计的主要成果,而概要设计的主要成果是软件概要设计说明书。

3. 划分模块可以降低软件的复杂度和工作量，所以应该将模块分得越小越好。（✗）
解释：错误。模块的划分需要适度,过小的模块会增加模块间的接口复杂度,反而增加系统的复杂性。

4. 软件设计中设计复审和设计本身一样重要，其主要作用是发现高代价的错误。（✓）
解释：正确。设计复审能够及早发现设计中的问题,避免这些问题在后期造成更大的损失。

第八章

1. 系统体系结构的最佳表现形式是一个可执行的软件原型。（✗）
解释：错误。系统体系结构应该用架构图、模块图等形式来表现,可执行原型并不是最佳表现形式。

2. 软件体系结构的描述是不同项目相关人员之间进行沟通的实现手段。（✓）
解释：正确。软件体系结构图是开发团队、项目经理、客户等相关人员之间沟通的重要工具。

3. 良好的分层体系结构有利于系统的扩展和维护。（✓）
解释：正确。良好的分层结构能够降低系统各部分的耦合度,使系统更容易扩展和维护。

4. 设计模式是从大量成功实践中总结出来并且被广泛公认的经验和知识。（✓）
解释：正确。设计模式是软件开发中经过实践检验的最佳解决方案。

第九章

1. 结构化软件设计方法关注于系统的功能，采用自顶向下、逐步求精的设计过程。（✓）
解释：正确。结构化设计方法确实是采用自顶向下的方式,通过功能分解来逐步细化系统功能。

2. SD法是一种面向数据结构的设计方法，强调程序结构与问题结构相对应。（✓）
解释：正确。SD(Structure Design)法强调根据数据结构来设计程序结构,使两者保持对应关系。

3. HIPO法既是需求分析方法，又是软件设计方法。（✓）
解释：正确。HIPO(Hierarchy plus Input-Process-Output)法可用于系统分析和设计两个阶段。

4. 面向数据结构设计方法一般包括下列任务：确定数据结构特征；用顺序、选择和重复3种基本形式表示数据等步骤。（✓）
解释：正确。这些都是面向数据结构设计方法的基本步骤。

第十章

1. 在面向对象的设计中，应遵循的设计准则除了模块化、抽象、低耦合和高内聚外，还有信息隐藏。（✓）
解释：正确。信息隐藏是面向对象设计的重要原则之一,它有助于提高系统的可维护性和可扩展性。

2. 面向对象分析和设计活动是一个多次反复迭代的过程。（✓）
解释：正确。面向对象方法强调迭代和增量式开发,分析和设计过程往往需要多次反复。

3. 关系数据库可以完全支持面向对象的概念，面向对象设计中的类可以直接对应到关系数据库中的表。（✗）
解释：错误。关系数据库和面向对象概念存在阻抗不匹配,比如继承、多态等特性在关系数据库中难以直接表达。

4. 面向对象设计是在分析模型的基础上，运用面向对象技术生成软件实现环境下的设计模型。（✓）
解释：正确。面向对象设计是将分析模型转换为可实现的设计模型的过程。

第十一章

1. C语言是一种纯面向对象语言。（✗）
解释：错误。C语言是面向过程的编程语言,不是面向对象语言。

2. 进行程序设计语言的选择时，首先考虑的是应用领域。（✓）
解释：正确。选择编程语言时应首先考虑项目的应用领域特点,选择最适合的语言。

3. 良好的设计风格就是高的编程技巧。（✗）
解释：错误。良好的设计风格不仅包括编程技巧,还包括代码的可读性、可维护性等多个方面。

4. 项目的应用领域是选择程序设计语言的关键因素。（✓）
解释：正确。不同的应用领域对编程语言的要求不同,这是选择语言时的关键考虑因素。

5. FORTRAN、Pascal、C语言和汇编语言都是科学工程计算可选用的语言。（✓）
解释：正确。这些语言都可用于科学计算,但各有特点和适用场景。

第十二章

1. 软件测试是对软件规格说明、软件设计和编码的最全面也是最后的审查。（✓）
解释：正确。软件测试是对软件各个方面进行全面检验的最后一道关口。

2. 如果通过软件测试没有发现错误，则说明软件是正确的。（✗）
解释：错误。测试只能证明存在错误,而不能证明没有错误。即使没有发现错误,也不能说明软件完全正确。

3. 软件测试的目的是尽可能多地发现软件中存在的错误，将它作为纠错的依据。（✓）
解释：正确。测试的主要目的是发现错误,为后续的纠错提供依据。

4. 测试用例由输入数据和预期的输出结果两部分组成。（✓）
解释：正确。一个完整的测试用例必须包含测试输入数据和预期的输出结果。

5. 软件测试的目的是证明软件是正确的。（✗）
解释：错误。软件测试的目的是发现错误,而不是证明软件正确。这是软件测试的基本原则。

第十三章

1. 白盒测试无须考虑模块内部的执行过程和程序结构，只需了解模块的功能即可。（✗）
解释：错误。白盒测试恰恰需要考察程序内部结构和执行路径,这是它区别于黑盒测试的主要特点。

2. 白盒测试是结构测试，主要以程序的内部逻辑为基础设计测试用例。（✓）
解释：正确。白盒测试基于程序内部逻辑结构设计测试用例,也称为结构测试。

3. 单元测试通常应该先进行"人工走查"，再以白盒法为主，辅以黑盒法进行动态测试。（✓）
解释：正确。这是单元测试的正确步骤,先静态检查再动态测试,并结合两种测试方法。

4. 白盒测试法是一种静态测试方法，主要用于模块测试。（✗）
解释：错误。白盒测试是动态测试方法,需要执行程序来验证其行为。

5. 在等价类划分类法中，一个测试用例应该只覆盖一个无效等价类。（✓）
解释：正确。这样可以在发现错误时准确定位问题所在。

6. 功能测试是系统测试的主要内容，检查系统的功能和性能是否符合需求规格说明相同。（✓）
解释：正确。功能测试是系统测试的核心内容,用于验证系统是否满足需求规格说明的要求。

第十四章

1. 代码行技术是比较简单的定量估算软件规模的方法。（✓）
解释：正确。代码行计数是最基本的软件规模度量方法,操作简单直观。

2. 功能点技术依据对软件信息特性和软件复杂性的评估结果，估算软件规模。（✓）
解释：正确。功能点分析通过评估软件的功能特性和复杂度来估算规模。

3. 常用的制订进度计划的工具主要有Word和Excel两种。（✗）
解释：错误。制订进度计划的工具还包括项目管理软件如Microsoft Project等专业工具。

4. 民主制程序员组的一个重要特点是，小组成员完全平等，享有充分民主，通过协商做出技术决策。（✓）
解释：正确。民主制团队强调成员平等参与决策。

5. 主程序员组的两个关键特性是专业化和层次性。（✓）
解释：正确。主程序员组织模式强调专业分工和明确的层次结构。

6. 现代程序员组中，技术组长既负责技术工作，又负责非技术事务。（✓）
解释：正确。技术组长需要同时承担技术和管理职责。

7. 风险有两个显著特点，一个是不确定性，另一个是损失。（✓）
解释：正确。风险的这两个特点决定了风险管理的重要性。

8. 回避风险是指，风险一旦发生，就接受后果。（✗）
解释：错误。回避风险是采取措施避免风险发生,而不是接受风险后果。

9. 软件质量保证的措施主要有，基于非执行的测试（也称为复审）、基于执行的测试和程序正确性证明。（✓）
解释：正确。这些都是保证软件质量的重要手段。

10. 总体上说，软件工程文档可以分为用户文档、开发文档和管理文档3类。（✓）
解释：正确。这是软件文档的基本分类方式。

11. 文档是影响软件可维护性的主要因素。（✓）
解释：正确。良好的文档对软件维护工作至关重要。

12. 适应性维护是在软件使用过程中，用户会对软件提出新的功能和性能要求，为了满足这些新的要求对软件进行修改，使之在功能和性能上得到不断增强的活动。（✓）
解释：正确。这准确描述了适应性维护的概念。

13. 进行软件维护活动时，直接修改程序，无须修改文档。（✗）
解释：错误。维护时需要同步更新程序和相关文档,保持文档的准确性。

14. 软件生命周期的最后一个阶段是写软件文档。（✗）
解释：错误。软件文档贯穿整个生命周期,最后阶段是软件淘汰。

15. CMM是指导软件开发的一种面向对象的新技术。（✗）
解释：错误。CMM(能力成熟度模型)是评估和改进软件过程的模型,不是开发技术。